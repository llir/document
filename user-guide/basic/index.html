<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic Introduction · llir/llvm</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">llir/llvm</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome to llir/llvm</a></li><li class="is-active"><a class="tocitem" href>Basic Introduction</a><ul class="internal"><li><a class="tocitem" href="#Module"><span>Module</span></a></li><li><a class="tocitem" href="#Global-Variable"><span>Global Variable</span></a></li><li><a class="tocitem" href="#Function"><span>Function</span></a></li><li><a class="tocitem" href="#Type"><span>Type</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../control/">Control Flow</a></li><li><a class="tocitem" href="../funcs/">More Function</a></li><li><a class="tocitem" href="../types/">High level types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basic Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/llir/document/blob/master/src/user-guide/basic.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-Introduction"><a class="docs-heading-anchor" href="#Basic-Introduction">Basic Introduction</a><a id="Basic-Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Introduction" title="Permalink"></a></h1><h2 id="Module"><a class="docs-heading-anchor" href="#Module">Module</a><a id="Module-1"></a><a class="docs-heading-anchor-permalink" href="#Module" title="Permalink"></a></h2><p>An LLVM IR file is a module. A module has many top-level entities:</p><ul><li>global variables</li><li>functions</li><li>types</li><li>metadata</li></ul><p>In this basic introduction, we won&#39;t dig into metadata, but instead focus on what we can do with global variables, functions, and types.</p><p><a href="https://github.com/llir/llvm">llir/llvm</a> provides package <a href="https://pkg.go.dev/github.com/llir/llvm/ir?tab=doc">ir</a> for these concepts. Let&#39;s see how a C program can be translated into LLVM IR using <a href="https://github.com/llir/llvm">llir/llvm</a>.</p><p>C example:</p><pre><code class="language-c hljs">int g = 2;

int add(int x, int y) {
  return x + y;
}
int main() {
  return add(1, g);
}</code></pre><p>Generate module:</p><pre><code class="language-go hljs">package main

import (
	&quot;github.com/llir/llvm/ir&quot;
	&quot;github.com/llir/llvm/ir/constant&quot;
	&quot;github.com/llir/llvm/ir/types&quot;
)

func main() {
	m := ir.NewModule()

	globalG := m.NewGlobalDef(&quot;g&quot;, constant.NewInt(types.I32, 2))

	funcAdd := m.NewFunc(&quot;add&quot;, types.I32,
		ir.NewParam(&quot;x&quot;, types.I32),
		ir.NewParam(&quot;y&quot;, types.I32),
	)
	ab := funcAdd.NewBlock(&quot;&quot;)
	ab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1]))

	funcMain := m.NewFunc(
		&quot;main&quot;,
		types.I32,
	)  // omit parameters
	mb := funcMain.NewBlock(&quot;&quot;) // llir/llvm would give correct default name for block without name
	mb.NewRet(mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG)))

	println(m.String())
}</code></pre><p>Generated IR:</p><pre><code class="language-llvm hljs">@g = global i32 2

define i32 @add(i32 %x, i32 %y) {
; &lt;label&gt;:0
	%1 = add i32 %x, %y
	ret i32 %1
}

define i32 @main() {
; &lt;label&gt;:0
	%1 = load i32, i32* @g
	%2 = call i32 @add(i32 1, i32 %1)
	ret i32 %2
}</code></pre><p>In this example, we have one global variable and two functions, mapping to C code. Now let&#39;s dig into global variables.</p><h2 id="Global-Variable"><a class="docs-heading-anchor" href="#Global-Variable">Global Variable</a><a id="Global-Variable-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Variable" title="Permalink"></a></h2><p>In LLVM IR assembly, the identifier of global variables are prefixed with an <code>@</code> character. Importantly, global variables are represented in LLVM as pointers, so we have to use <a href="https://pkg.go.dev/github.com/llir/llvm/ir?tab=doc#InstLoad">load</a> to retreive the value and <a href="https://pkg.go.dev/github.com/llir/llvm/ir?tab=doc#InstStore">store</a> to update the value of a global variable.</p><h2 id="Function"><a class="docs-heading-anchor" href="#Function">Function</a><a id="Function-1"></a><a class="docs-heading-anchor-permalink" href="#Function" title="Permalink"></a></h2><p>Like globals, in LLVM IR assembly the identifier of functions are prefixed with an <code>@</code> character. Functions composed by a function prototype and a group of basic blocks. A function without basic blocks is a function declaration. The following code would generate a function declaration:</p><pre><code class="language-go hljs">m.NewFunc(
    &quot;add&quot;,
	types.I32,
    ir.NewParam(&quot;&quot;, types.I32),
	ir.NewParam(&quot;&quot;, types.I32),
)</code></pre><p>Output:</p><pre><code class="language-llvm hljs">declare i32 @add(i32 %0, i32 %1)</code></pre><p>When we want to bind to existing functions defined in other object files, we would create function declarations.</p><h3 id="Function-Prototype"><a class="docs-heading-anchor" href="#Function-Prototype">Function Prototype</a><a id="Function-Prototype-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Prototype" title="Permalink"></a></h3><p>A function prototype or function signature defines the parameters and return type of a function.</p><h3 id="Basic-Block"><a class="docs-heading-anchor" href="#Basic-Block">Basic Block</a><a id="Basic-Block-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Block" title="Permalink"></a></h3><p>If function is group of basic blocks, then a basic block is a group of instructions. The basic notion behind a basic block is that if any instruction of a basic block is executed, then all instructions of the basic block are executed. In other words, there may be no branching or terminating instruction in the middle of a basic block, and all incoming branches must transfer control flow to the first instruction of the basic block.</p><p>It is worthwhile to note that most high-level expression would be lowered into a set of instructions, covering one or more basic blocks.</p><p><a href="https://github.com/llir/llvm">llir/llvm</a> provides API to create instructions by a basic block. For further information, refer to the <a href="https://pkg.go.dev/github.com/llir/llvm/ir?tab=doc#Block">Block API documentation</a>.</p><h3 id="Instruction"><a class="docs-heading-anchor" href="#Instruction">Instruction</a><a id="Instruction-1"></a><a class="docs-heading-anchor-permalink" href="#Instruction" title="Permalink"></a></h3><p>An instruction is a set of operations on assembly abstraction level which operate on an abstract machine model, as defined by LLVM. For further information, refer to the <a href="https://llvm.org/docs/LangRef.html#instruction-reference">Instruction Reference section of the LLVM Language Reference Manual</a>.</p><h2 id="Type"><a class="docs-heading-anchor" href="#Type">Type</a><a id="Type-1"></a><a class="docs-heading-anchor-permalink" href="#Type" title="Permalink"></a></h2><p>There are many types in LLVM type system, here we focus on how to create a new type.</p><pre><code class="language-go hljs">m := ir.NewModule()

m.NewTypeDef(&quot;foo&quot;, types.NewStruct(types.I32))</code></pre><p>The above code would produce the following IR:</p><pre><code class="language-llvm hljs">%foo = type { i32 }</code></pre><p>Which could be mapped to the following C code:</p><pre><code class="language-c hljs">typedef struct {
  int x;
} foo;</code></pre><p>Notice that in LLVM, structure fields have no name.</p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>We hope that the previous sections have provide enough information about how to get use the documentation to dig into details. We will not dig into the details of each instruction; instead, we aim to provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Welcome to llir/llvm</a><a class="docs-footer-nextpage" href="../control/">Control Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 13 December 2021 16:16">Monday 13 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
