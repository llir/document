var documenterSearchIndex = {"docs":
[{"location":"user-guide/support/#Support","page":"Support","title":"Support","text":"","category":"section"},{"location":"user-guide/support/","page":"Support","title":"Support","text":"You can access our helper code here.","category":"page"},{"location":"user-guide/basic/#Basic-Introduction","page":"Basic Introduction","title":"Basic Introduction","text":"","category":"section"},{"location":"user-guide/basic/#Module","page":"Basic Introduction","title":"Module","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"An LLVM IR file is a module. A module has many top-level entities:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"global variables\nfunctions\ntypes\nmetadata","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"In this basic introduction, we won't dig into metadata, but instead focus on what we can do with global variables, functions, and types.","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"llir/llvm provides package ir for these concepts. Let's see how a C program can be translated into LLVM IR using llir/llvm.","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"C example:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"int g = 2;\n\nint add(int x, int y) {\n  return x + y;\n}\nint main() {\n  return add(1, g);\n}","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"Generate module:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"package main\n\nimport (\n\t\"github.com/llir/llvm/ir\"\n\t\"github.com/llir/llvm/ir/constant\"\n\t\"github.com/llir/llvm/ir/types\"\n)\n\nfunc main() {\n\tm := ir.NewModule()\n\n\tglobalG := m.NewGlobalDef(\"g\", constant.NewInt(types.I32, 2))\n\n\tfuncAdd := m.NewFunc(\"add\", types.I32,\n\t\tir.NewParam(\"x\", types.I32),\n\t\tir.NewParam(\"y\", types.I32),\n\t)\n\tab := funcAdd.NewBlock(\"\")\n\tab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1]))\n\n\tfuncMain := m.NewFunc(\n\t\t\"main\",\n\t\ttypes.I32,\n\t)  // omit parameters\n\tmb := funcMain.NewBlock(\"\") // llir/llvm would give correct default name for block without name\n\tmb.NewRet(mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG)))\n\n\tprintln(m.String())\n}","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"Generated IR:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"@g = global i32 2\n\ndefine i32 @add(i32 %x, i32 %y) {\n; <label>:0\n\t%1 = add i32 %x, %y\n\tret i32 %1\n}\n\ndefine i32 @main() {\n; <label>:0\n\t%1 = load i32, i32* @g\n\t%2 = call i32 @add(i32 1, i32 %1)\n\tret i32 %2\n}","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"In this example, we have one global variable and two functions, mapping to C code. Now let's dig into global variables.","category":"page"},{"location":"user-guide/basic/#Global-Variable","page":"Basic Introduction","title":"Global Variable","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"In LLVM IR assembly, the identifier of global variables are prefixed with an @ character. Importantly, global variables are represented in LLVM as pointers, so we have to use load to retreive the value and store to update the value of a global variable.","category":"page"},{"location":"user-guide/basic/#Function","page":"Basic Introduction","title":"Function","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"Like globals, in LLVM IR assembly the identifier of functions are prefixed with an @ character. Functions composed by a function prototype and a group of basic blocks. A function without basic blocks is a function declaration. The following code would generate a function declaration:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"m.NewFunc(\n    \"add\",\n\ttypes.I32,\n    ir.NewParam(\"\", types.I32),\n\tir.NewParam(\"\", types.I32),\n)","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"Output:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"declare i32 @add(i32 %0, i32 %1)","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"When we want to bind to existing functions defined in other object files, we would create function declarations.","category":"page"},{"location":"user-guide/basic/#Function-Prototype","page":"Basic Introduction","title":"Function Prototype","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"A function prototype or function signature defines the parameters and return type of a function.","category":"page"},{"location":"user-guide/basic/#Basic-Block","page":"Basic Introduction","title":"Basic Block","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"If function is group of basic blocks, then a basic block is a group of instructions. The basic notion behind a basic block is that if any instruction of a basic block is executed, then all instructions of the basic block are executed. In other words, there may be no branching or terminating instruction in the middle of a basic block, and all incoming branches must transfer control flow to the first instruction of the basic block.","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"It is worthwhile to note that most high-level expression would be lowered into a set of instructions, covering one or more basic blocks.","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"llir/llvm provides API to create instructions by a basic block. For further information, refer to the Block API documentation.","category":"page"},{"location":"user-guide/basic/#Instruction","page":"Basic Introduction","title":"Instruction","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"An instruction is a set of operations on assembly abstraction level which operate on an abstract machine model, as defined by LLVM. For further information, refer to the Instruction Reference section of the LLVM Language Reference Manual.","category":"page"},{"location":"user-guide/basic/#Type","page":"Basic Introduction","title":"Type","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"There are many types in LLVM type system, here we focus on how to create a new type.","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"m := ir.NewModule()\n\nm.NewTypeDef(\"foo\", types.NewStruct(types.I32))","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"The above code would produce the following IR:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"%foo = type { i32 }","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"Which could be mapped to the following C code:","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"typedef struct {\n  int x;\n} foo;","category":"page"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"Notice that in LLVM, structure fields have no name.","category":"page"},{"location":"user-guide/basic/#Conclusion","page":"Basic Introduction","title":"Conclusion","text":"","category":"section"},{"location":"user-guide/basic/","page":"Basic Introduction","title":"Basic Introduction","text":"We hope that the previous sections have provide enough information about how to get use the documentation to dig into details. We will not dig into the details of each instruction; instead, we aim to provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.","category":"page"},{"location":"user-guide/types/#High-level-types","page":"High level types","title":"High level types","text":"","category":"section"},{"location":"user-guide/types/#Structure","page":"High level types","title":"Structure","text":"","category":"section"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Structure is quite common and basic type in programming language. Here focus on how to create an equal LLVM mapping for structure.","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"LLVM has the concept about structure type, but structure type in LLVM didn't have field name, how to get/set fields of structure would be a thing. Let's assume a structure: foo has a field named x with type i32. Below code shows how to access x.","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"zero := constant.NewInt(types.I32, 0)\nm := ir.NewModule()\n\nfoo := m.NewTypeDef(\"foo\", types.NewStruct(types.I32))\n\nmain := m.NewFunc(\"main\", types.I32)\nb := main.NewBlock(\"\")\nfooInstance := b.NewAlloca(foo)\nfieldX := b.NewGetElementPtr(foo, fooInstance, zero, zero)\n// now `fieldX` is a pointer to field `x` of `foo`.\nb.NewStore(constant.NewInt(types.I32, 10), fieldX)\nb.NewLoad(types.I32, fieldX)\nb.NewRet(zero)","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Get element pointer(a.k.a. GEP) is the point here. It computes a pointer to any structure member with no overhead. Then load and store can work on it.","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"To get more information about GEP can goto Lang Ref.","category":"page"},{"location":"user-guide/types/#Array","page":"High level types","title":"Array","text":"","category":"section"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Arrays are a sequence of elements of the same types in LLVM. And in LLVM, array size is a constant that never changes. In the following text, I will present how to define a global array, and how to operate it.","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"As usual, we need a module and some helping code","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"mod := ir.NewModule()\nprintf := PrintfPlugin(mod)\nformatString := \"array_def[%d]: %d\\n\"\nfmtStr := mod.NewGlobalDef(\"x\", irutil.NewCString(formatString))\nmain := mod.NewFunc(\"main\", types.I32)\nmainB := main.NewBlock(\"\")\nptrToStr := mainB.NewGetElementPtr(types.NewArray(uint64(len(formatString)), types.I8), fmtStr, CI32(0), CI32(0))","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Now we create a global array","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"arrTy := types.NewArray(5, types.I8)\narrayDef := mod.NewGlobalDef(\"array_def\", constant.NewArray(arrTy, CI8(1), CI8(2), CI8(3), CI8(4), CI8(5)))","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Then we can load it into stack, in the following code, we","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"extract value from loaded array\ninsert value into loaded array","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"arr := mainB.NewLoad(arrTy, arrayDef)\nfor i := 0; i < 5; i++ {\n\tmainB.NewCall(printf, ptrToStr, CI32(int64(i)), mainB.NewExtractValue(arr, uint64(i)))\n\tmainB.NewInsertValue(arr, CI8(0), uint64(i))\n\tmainB.NewCall(printf, ptrToStr, CI32(int64(i)), mainB.NewExtractValue(arr, uint64(i)))\n}","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Another way to get element and update it is using get element pointer(a.k.a GEP)","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"for i := 0; i < 5; i++ {\n\tpToElem := mainB.NewGetElementPtr(arrTy, arrayDef, CI32(0), CI32(int64(i)))\n\tmainB.NewCall(printf, ptrToStr, CI32(int64(i)), mainB.NewLoad(types.I8, pToElem))\n\tmainB.NewStore(CI8(0), pToElem)\n\tmainB.NewCall(printf, ptrToStr, CI32(int64(i)), mainB.NewLoad(types.I8, pToElem))\n}","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"compare with previous result, you will find previous insert didn't work as expected. So this is the key point about insert value. It don't update your aggregate value, it do thing like immutable programming: take and return new one. Thus, we should write","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"for i := 0; i < 5; i++ {\n\tmainB.NewCall(printf, ptrToStr, CI32(int64(i)), mainB.NewExtractValue(arr, uint64(i)))\n\tnewArr := mainB.NewInsertValue(arr, CI8(0), uint64(i))\n\tmainB.NewCall(printf, ptrToStr, CI32(int64(i)), mainB.NewExtractValue(newArr, uint64(i)))\n}","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Now you should understand array enough to compile your language into this aggregate type!","category":"page"},{"location":"user-guide/types/#Algebra-Data-Type","page":"High level types","title":"Algebra Data Type","text":"","category":"section"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"Algebra data type is a common concept in functional programming language. For example, Haskell can write:","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"data Expr =\n  EInt Int\n  | EBool Bool\n  | EString String","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"How to express such concept in LLVM? The idea was selecting the biggest size in all variants and use it as the size of this type. Do bitcast when need to access the actual value. Here is the code:","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"mod := ir.NewModule()\n\ntypeExpr := mod.NewTypeDef(\"Expr\", types.NewStruct(\n\ttypes.I8,\n\ttypes.NewArray(8, types.I8),\n))\n// variant tag 0\ntypeExprInt := mod.NewTypeDef(\"EInt\", types.NewStruct(\n\ttypes.I8,\n\ttypes.I32,\n))\n// variant tag 1\nmod.NewTypeDef(\"EBool\", types.NewStruct(\n\ttypes.I8,\n\ttypes.I1,\n))\n// variant tag 2\nmod.NewTypeDef(\"EString\", types.NewStruct(\n\ttypes.I8,\n\ttypes.NewPointer(types.I8),\n))\n\nmain := mod.NewFunc(\n\t\"main\",\n\ttypes.I32,\n)\nb := main.NewBlock(\"\")\nexprInstance := b.NewAlloca(typeExpr)\nexprTag := b.NewGetElementPtr(typeExpr, exprInstance, constI32(0), constI32(0))\n// set tag to 0\nb.NewStore(constI8(0), exprTag)\nexprIntInstance := b.NewBitCast(exprInstance, types.NewPointer(typeExprInt))\nexprIntValue := b.NewGetElementPtr(typeExprInt, exprIntInstance, constI32(0), constI32(1))\nb.NewStore(constI32(2), exprIntValue)\nb.NewRet(constI32(0))","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"These code produce:","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"%Expr = type { i8, [8 x i8] }\n%EInt = type { i8, i32 }\n%EBool = type { i8, i1 }\n%EString = type { i8, i8* }\n\ndefine i32 @main() {\n; <label>:0\n\t%1 = alloca %Expr\n\t%2 = getelementptr %Expr, %Expr* %1, i32 0, i32 0\n\tstore i8 0, i8* %2\n\t%3 = bitcast %Expr* %1 to %EInt*\n\t%4 = getelementptr %EInt, %EInt* %3, i32 0, i32 1\n\tstore i32 2, i32* %4\n\tret i32 0\n}","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"tag in each variant is important, for example, pattern matching in Haskell looks like:","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"case expr of\n  EInt i -> \"int\"\n  EBool b -> \"bool\"\n  EString s -> \"string\"","category":"page"},{"location":"user-guide/types/","page":"High level types","title":"High level types","text":"case expression would need tag to distinguish variant.","category":"page"},{"location":"user-guide/control/#Control-Flow","page":"Control Flow","title":"Control Flow","text":"","category":"section"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Before we start, we need to prepare compile function for something like expression and statement that not our target.","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type Expr interface{ isExpr() Expr }\ntype EConstant interface {\n\tExpr\n\tisEConstant() EConstant\n}\ntype EVoid struct{ EConstant }\ntype EBool struct {\n\tEConstant\n\tV bool\n}\ntype EI32 struct {\n\tEConstant\n\tV int64\n}\ntype EVariable struct {\n\tExpr\n\tName string\n}\ntype EAdd struct {\n\tExpr\n\tLhs, Rhs Expr\n}\ntype ELessThan struct {\n\tExpr\n\tLhs, Rhs Expr\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"And compile functions:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"func compileConstant(e EConstant) constant.Constant {\n\tswitch e := e.(type) {\n\tcase *EI32:\n\t\treturn constant.NewInt(types.I32, e.V)\n\tcase *EBool:\n\t\t// we have no boolean in LLVM IR\n\t\tif e.V {\n\t\t\treturn constant.NewInt(types.I1, 1)\n\t\t} else {\n\t\t\treturn constant.NewInt(types.I1, 0)\n\t\t}\n\tcase *EVoid:\n\t\treturn nil\n\t}\n\tpanic(\"unknown expression\")\n}\n\nfunc (ctx *Context) compileExpr(e Expr) value.Value {\n\tswitch e := e.(type) {\n\tcase *EVariable:\n\t\treturn ctx.lookupVariable(e.Name)\n\tcase *EAdd:\n\t\tl, r := ctx.compileExpr(e.Lhs), ctx.compileExpr(e.Rhs)\n\t\treturn ctx.NewAdd(l, r)\n\tcase *ELessThan:\n\t\tl, r := ctx.compileExpr(e.Lhs), ctx.compileExpr(e.Rhs)\n\t\treturn ctx.NewICmp(enum.IPredSLT, l, r)\n\tcase EConstant:\n\t\treturn compileConstant(e)\n\t}\n\tpanic(\"unimplemented expression\")\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"EVariable would need context to remember variable's value. Here is the related definition of Context:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type Context struct {\n\t*ir.Block\n\tparent *Context\n\tvars   map[string]value.Value\n}\n\nfunc NewContext(b *ir.Block) *Context {\n\treturn &Context{\n\t\tBlock: b,\n\t\tparent:   nil,\n\t\tvars:     make(map[string]value.Value),\n\t}\n}\n\nfunc (c *Context) NewContext(b *ir.Block) *Context {\n\tctx := NewContext(b)\n\tctx.parent = c\n\treturn ctx\n}\n\nfunc (c Context) lookupVariable(name string) value.Value {\n\tif v, ok := c.vars[name]; ok {\n\t\treturn v\n\t} else if c.parent != nil {\n\t\treturn c.parent.lookupVariable(name)\n\t} else {\n\t\tfmt.Printf(\"variable: `%s`\\n\", name)\n\t\tpanic(\"no such variable\")\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Finally, we would have some simple statement as placeholder:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type Stmt interface{ isStmt() Stmt }\ntype SDefine struct {\n\tStmt\n\tName string\n\tTyp  types.Type\n\tExpr Expr\n}\ntype SRet struct {\n\tStmt\n\tVal Expr\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Then compile:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"func (ctx *Context) compileStmt(stmt Stmt) {\n\tif ctx.Parent != nil {\n\t\treturn\n\t}\n\tf := ctx.Parent\n\tswitch s := stmt.(type) {\n\tcase *SDefine:\n\t\tv := ctx.NewAlloca(s.Typ)\n\t\tctx.NewStore(ctx.compileExpr(s.Expr), v)\n\t\tctx.vars[s.Name] = v\n\tcase *SRet:\n\t\tctx.NewRet(ctx.compileExpr(s.Val))\n\t}\n}","category":"page"},{"location":"user-guide/control/#If","page":"Control Flow","title":"If","text":"","category":"section"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Since we can let:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"if condition {\n    // A\n} else if condition {\n    // B\n} else {\n    // C\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"became:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"if condition {\n    // A\n} else {\n    if condition {\n        // B\n    } else {\n        // C\n    }\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"We don't have to convert any else-if pattern. Therefore, our If looks like this:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type SIf struct {\n\tStmt\n\tCond Expr\n\tThen Stmt\n\tElse Stmt\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Then we can get transformers to generate control flow if. Using conditional jump to generate if statement:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"func (ctx *Context) compileStmt(stmt Stmt) {\n\tswitch s := stmt.(type) {\n\tcase *SIf:\n\t\tthenCtx := ctx.NewContext(f.NewBlock(\"if.then\"))\n\t\tthenCtx.compileStmt(s.Then)\n\t\telseB := f.NewBlock(\"if.else\")\n\t\tctx.NewContext(elseB).compileStmt(s.Else)\n\t\tctx.NewCondBr(ctx.compileExpr(s.Cond), thenCtx.Block, elseB)\n\t\tif !thenCtx.HasTerminator() {\n\t\t\tleaveB := f.NewBlock(\"leave.if\")\n\t\t\tthenCtx.NewBr(leaveB)\n\t\t}\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"When generating if, the most important thing is leave block, when if-then block complete, a jump to skip else block required since there has no block in high-level language liked concept in LLVM IR. At the end of a basic-block can be a return and since return would terminate a function, jump after return is a dead code, so we have to check we have to generate leave block or not. Here is a small example as usage:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"f := ir.NewFunc(\"foo\", types.Void)\nbb := f.NewBlock(\"\")\n\nctx.compileStmt(&SIf{\n    Cond: &EBool{V: true},\n    Then: &SRet{Val: &EVoid{}},\n    Else: &SRet{Val: &EVoid{}},\n})","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Finally, we get:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"define void @foo() {\n0:\n\tbr i1 true, label %if.then, label %if.else\n\nif.then:\n\tret void\n\nif.else:\n\tret void\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"We didn't support else-if directly at here, then we need to know how to handle this via parsing. First, we handle a sequence of if ( <expr> ) <block>. Ok, we can fill AST with Cond and Then, now we should get a token else, then we expect a <block> or if. When we get a <block> this is a obviously can be use as Else, else a if we keep parsing and use it as Else statement since if for sure is a statement. Of course, with this method, generated IR would have some useless label and jump, but flow analyzing should optimize them later, so it's fine.","category":"page"},{"location":"user-guide/control/#Switch","page":"Control Flow","title":"Switch","text":"","category":"section"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"LLVM has switch instruction, hence, we can use it directly.","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type SSwitch struct {\n\tStmt\n\tTarget   Expr\n\tCaseList []struct {\n\t\tEConstant // LLVM IR only takes constant, if you want advanced switch semantic, then you can't directly use this approach\n\t\tStmt\n\t}\n\tDefaultCase Stmt\n}\n\nfunc (ctx *Context) compileStmt(stmt Stmt) {\n\tswitch s := stmt.(type) {\n\tcase *SSwitch:\n\t\tcases := []*ir.Case{}\n\t\tfor _, ca := range s.CaseList {\n\t\t\tcaseB := f.NewBlock(\"switch.case\")\n\t\t\tctx.NewContext(caseB).compileStmt(ca.Stmt)\n\t\t\tcases = append(cases, ir.NewCase(compileConstant(ca.EConstant), caseB))\n\t\t}\n\t\tdefaultB := f.NewBlock(\"switch.default\")\n\t\tctx.NewContext(defaultB).compileStmt(s.DefaultCase)\n\t\tctx.NewSwitch(ctx.compileExpr(s.Target), defaultB, cases...)\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"For every case, we generate a block, then we can jump to target. Then we put statements into case blocks. Finally, we generate switch for the input block. Notice that, switch instruction of LLVM won't generate break automatically, you can use the same trick in the previous section If to generate auto leave block for each case(Go semantic), or record leave block and introduces break statement(C semantic). Now let's test it:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"f := ir.NewFunc(\"foo\", types.Void)\nctx := NewContext(f.NewBlock(\"\"))\n\nctx.compileStmt(&SSwitch{\n\tTarget: &EBool{V: true},\n\tCaseList: []struct {\n\t\tEConstant\n\t\tStmt\n\t}{\n\t\t{EConstant: &EBool{V: true}, Stmt: &SRet{Val: &EVoid{}}},\n\t},\n\tDefaultCase: &SRet{Val: &EVoid{}},\n})","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"And output:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"define void @foo() {\n0:\n\tswitch i1 true, label %switch.default [\n\t\ti1 true, label %switch.case\n\t]\n\nswitch.case:\n\tret void\n\nswitch.default:\n\tret void\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"The switch statement in this section is quite naive, for advanced semantic like pattern matching with extraction or where clause, you would need to do more.","category":"page"},{"location":"user-guide/control/#Loop","page":"Control Flow","title":"Loop","text":"","category":"section"},{"location":"user-guide/control/#Break","page":"Control Flow","title":"Break","text":"","category":"section"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Break statement needs to extend Context, with a new field called leaveBlock:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type Context struct {\n\t// ...\n\tleaveBlock *ir.Block\n}\n\nfunc NewContext(b *ir.Block) *Context {\n\treturn &Context{\n\t\t// ...\n\t\tleaveBlock: nil,\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Then it's just a jump:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"func (ctx *Context) compileStmt(stmt Stmt) {\n\tswitch s := stmt.(type) {\n\tcase *SBreak:\n\t\tctx.NewBr(ctx.leaveBlock)\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Remember to update leave block information(and remove it when needed), and continue can be done in the same way.","category":"page"},{"location":"user-guide/control/#Do-While","page":"Control Flow","title":"Do While","text":"","category":"section"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Do while is the simplest loop structure since it's code structure almost same to the IR structure. Here we go:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type SDoWhile struct {\n\tStmt\n\tCond  Expr\n\tBlock Stmt\n}\n\nfunc (ctx *Context) compileStmt(stmt Stmt) {\n\tswitch s := stmt.(type) {\n\tcase *SDoWhile:\n\t\tdoCtx := ctx.NewContext(f.NewBlock(\"do.while.body\"))\n\t\tctx.NewBr(doCtx.Block)\n\t\tleaveB := f.NewBlock(\"leave.do.while\")\n\t\tdoCtx.leaveBlock = leaveB\n\t\tdoCtx.compileStmt(s.Block)\n\t\tdoCtx.NewCondBr(doCtx.compileExpr(s.Cond), doCtx.Block, leaveB)\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Can see that, we jump to do-while body directly. Then we have a leave block, in the end of the do-while body we jump out to leave block or body again depends on condition. Let's test it:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"f := ir.NewFunc(\"foo\", types.Void)\nctx := NewContext(f.NewBlock(\"\"))\n\nctx.compileStmt(&SDoWhile{\n\tCond: &EBool{V: true},\n\tBlock: &SDefine{\n\t\tStmt: nil,\n\t\tName: \"foo\",\n\t\tTyp:  types.I32,\n\t\tExpr: &EI32{V: 1},\n\t},\n})\n\nf.Blocks[len(f.Blocks)-1].NewRet(nil)","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"And output:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"define void @foo() {\n0:\n\tbr label %do.while.body\n\ndo.while.body:\n\t%1 = alloca i32\n\tstore i32 1, i32* %1\n\tbr i1 true, label %do.while.body, label %leave.do.while\n\nleave.do.while:\n\tret void\n}","category":"page"},{"location":"user-guide/control/#For-Loop","page":"Control Flow","title":"For Loop","text":"","category":"section"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"For-loop would be an interesting case, at here, I only present a for-loop that can only have one initialize variable to reduce complexity, therefore, we have a AST like this:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type SForLoop struct {\n\tStmt\n\tInitName string\n\tInitExpr Expr\n\tStep     Expr\n\tCond     Expr\n\tBlock    Stmt\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"For example, for (x=0; x=x+1; x<10) {} break down to:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"SForLoop {\n\tInitName: `x`\n\tInitExpr: `0`\n\tStep: `x + 1`\n\tCond: `x < 10`\n\tBlock: `{}`\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"At first view, people might think for-loop is as easy as do-while, but in SSA form, reuse variable in a loop need a new instruction: phi.","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"func (ctx *Context) compileStmt(stmt Stmt) {\n\tswitch s := stmt.(type) {\n\tcase *SForLoop:\n\t\tloopCtx := ctx.NewContext(f.NewBlock(\"for.loop.body\"))\n\t\tctx.NewBr(loopCtx.Block)\n\t\tfirstAppear := loopCtx.NewPhi(ir.NewIncoming(loopCtx.compileExpr(s.InitExpr), ctx.Block))\n\t\tloopCtx.vars[s.InitName] = firstAppear\n\t\tstep := loopCtx.compileExpr(s.Step)\n\t\tfirstAppear.Incs = append(firstAppear.Incs, ir.NewIncoming(step, loopCtx.Block))\n\t\tloopCtx.vars[s.InitName] = step\n\t\tleaveB := f.NewBlock(\"leave.for.loop\")\n\t\tloopCtx.leaveBlock = leaveB\n\t\tloopCtx.compileStmt(s.Block)\n\t\tloopCtx.NewCondBr(loopCtx.compileExpr(s.Cond), loopCtx.Block, leaveB)\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Create a loop body context\njump from the previous block\nPut phi into loop body\nPhi would have two incoming, first is InitExpr, the second one is Step result.\ncompile step\ncompile the conditional branch, jump to loop body or leave block","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Testing:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"f := ir.NewFunc(\"foo\", types.Void)\nctx := NewContext(f.NewBlock(\"\"))\n\nctx.compileStmt(&SForLoop{\n\tInitName: \"x\",\n\tInitExpr: &EI32{V: 0},\n\tStep:     &EAdd{Lhs: &EVariable{Name: \"x\"}, Rhs: &EI32{V: 1}},\n\tCond:     &ELessThan{Lhs: &EVariable{Name: \"x\"}, Rhs: &EI32{V: 10}},\n\tBlock:    &SDefine{Name: \"foo\", Typ: types.I32, Expr: &EI32{V: 2}},\n})\n\nf.Blocks[len(f.Blocks)-1].NewRet(nil)","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"The test generates:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"define void @foo() {\n0:\n\tbr label %for.loop.body\n\nfor.loop.body:\n\t%1 = phi i32 [ 0, %0 ], [ %2, %for.loop.body ]\n\t%2 = add i32 %1, 1\n\t%3 = alloca i32\n\tstore i32 2, i32* %3\n\t%4 = icmp slt i32 %2, 10\n\tbr i1 %4, label %for.loop.body, label %leave.for.loop\n\nleave.for.loop:\n\tret void\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"In fact, you can also avoid phi, you can make a try as practice.","category":"page"},{"location":"user-guide/control/#While","page":"Control Flow","title":"While","text":"","category":"section"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"The last kind of loop we want to present is while loop.","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"type SWhile struct {\n\tStmt\n\tCond  Expr\n\tBlock Stmt\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"It looks just like do while, but have different semantic, it might not execute it's body. Here is the implementation.","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"func (ctx *Context) compileStmt(stmt Stmt) {\n\tswitch s := stmt.(type) {\n\tcase *SWhile:\n\t\tcondCtx := ctx.NewContext(f.NewBlock(\"while.loop.cond\"))\n\t\tctx.NewBr(condCtx.Block)\n\t\tloopCtx := ctx.NewContext(f.NewBlock(\"while.loop.body\"))\n\t\tleaveB := f.NewBlock(\"leave.do.while\")\n\t\tcondCtx.NewCondBr(condCtx.compileExpr(s.Cond), loopCtx.Block, leaveB)\n\t\tcondCtx.leaveBlock = leaveB\n\t\tloopCtx.leaveBlock = leaveB\n\t\tloopCtx.compileStmt(s.Block)\n\t\tloopCtx.NewBr(condCtx.Block)\n\t}\n}","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"We would need two blocks since br is a terminator, then the logic is simple:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"while.loop.cond would jump to while.loop.body or leave.do.while by condition\nwhile.loop.body always back to while.loop.cond.","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"Finally, test:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"f := ir.NewFunc(\"foo\", types.Void)\nctx := NewContext(f.NewBlock(\"\"))\n\nctx.compileStmt(&SWhile{\n\tCond: &EBool{V: true},\n\tBlock: &SDefine{\n\t\tName: \"x\",\n\t\tTyp:  types.I32,\n\t\tExpr: &EI32{V: 0},\n\t},\n})\n\nf.Blocks[len(f.Blocks)-1].NewRet(nil)","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"and output:","category":"page"},{"location":"user-guide/control/","page":"Control Flow","title":"Control Flow","text":"define void @foo() {\n0:\n\tbr label %while.loop.cond\n\nwhile.loop.cond:\n\tbr i1 true, label %while.loop.body, label %leave.do.while\n\nwhile.loop.body:\n\t%1 = alloca i32\n\tstore i32 0, i32* %1\n\tbr label %while.loop.cond\n\nleave.do.while:\n\tret void\n}","category":"page"},{"location":"user-guide/funcs/#More-Function","page":"More Function","title":"More Function","text":"","category":"section"},{"location":"user-guide/funcs/#Linkage","page":"More Function","title":"Linkage","text":"","category":"section"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"The following code shows some linkage can use in IR.","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"m := ir.NewModule()\n\nadd := m.NewFunc(\"add\", types.I64, ir.NewParam(\"\", types.I64))\nadd.Linkage = enum.LinkageInternal\nadd1 := m.NewFunc(\"add1\", types.I64, ir.NewParam(\"\", types.I64))\nadd1.Linkage = enum.LinkageLinkOnce\nadd2 := m.NewFunc(\"add2\", types.I64, ir.NewParam(\"\", types.I64))\nadd2.Linkage = enum.LinkagePrivate\nadd3 := m.NewFunc(\"add3\", types.I64, ir.NewParam(\"\", types.I64))\nadd3.Linkage = enum.LinkageWeak\nadd4 := m.NewFunc(\"add4\", types.I64, ir.NewParam(\"\", types.I64))\nadd4.Linkage = enum.LinkageExternal","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"The code would produce:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"declare internal i64 @add(i64)\n\ndeclare linkonce i64 @add1(i64)\n\ndeclare private i64 @add2(i64)\n\ndeclare weak i64 @add3(i64)\n\ndeclare external i64 @add4(i64)","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"For further information about linkage, refer to LLVM doc and pkg.go.dev.","category":"page"},{"location":"user-guide/funcs/#Variant-Argument-(a.k.a.-VAArg)","page":"More Function","title":"Variant Argument (a.k.a. VAArg)","text":"","category":"section"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"One example of a variadic function is printf. This is how to create a function prototype for printf:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"m := ir.NewModule()\n\nprintf := m.NewFunc(\n\t\"printf\",\n\ttypes.I32,\n\tir.NewParam(\"\", types.NewPointer(types.I8)),\n)\nprintf.Sig.Variadic = true","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"The above code would produce the following IR:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"declare i32 @printf(i8*, ...)","category":"page"},{"location":"user-guide/funcs/#Function-Overloading","page":"More Function","title":"Function Overloading","text":"","category":"section"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"There is no overloading in LLVM IR. One solution is to create one function per function signature, where each LLVM IR function would have a unique name (this is why C++ compilers do name mangling).","category":"page"},{"location":"user-guide/funcs/#First-class-Function(Closure)","page":"More Function","title":"First-class Function(Closure)","text":"","category":"section"},{"location":"user-guide/funcs/#Naive-Implementation","page":"More Function","title":"Naive Implementation","text":"","category":"section"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"Create a closure(a.k.a. first-class function) requires a place to store captured variables. In LLVM, the best way is create a structure for such case:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"m := ir.NewModule()\n\nzero := constant.NewInt(types.I32, 0)\none := constant.NewInt(types.I32, 1)\n\ncaptureStruct := m.NewTypeDef(\"id_capture\", types.NewStruct(\n\ttypes.I32,\n))\ncaptureTyp := types.NewPointer(captureStruct)\nidFn := m.NewFunc(\"id\", types.I32, ir.NewParam(\"capture\", captureTyp))\nidB := idFn.NewBlock(\"\")\nv := idB.NewGetElementPtr(captureStruct, idFn.Params[0], zero, zero)\nidB.NewRet(idB.NewLoad(types.I32, v))\nidClosureTyp := m.NewTypeDef(\"id_closure\", types.NewStruct(\n\tcaptureTyp,\n\tidFn.Type(),\n))\n\nmainFn := m.NewFunc(\"main\", types.I32)\nb := mainFn.NewBlock(\"\")\n// define a local variable `i`\ni := b.NewAlloca(types.I32)\nb.NewStore(constant.NewInt(types.I32, 10), i)\n// use alloca at here to simplify code, in real case should be `malloc` or `gc_malloc`\ncaptureInstance := b.NewAlloca(captureStruct)\nptrToCapture := b.NewGetElementPtr(captureStruct, captureInstance, zero, zero)\n// capture variable\nb.NewStore(b.NewLoad(types.I32, i), ptrToCapture)\n// prepare closure\nidClosure := b.NewAlloca(idClosureTyp)\nptrToCapturePtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero)\nb.NewStore(captureInstance, ptrToCapturePtr)\nptrToFuncPtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one)\nb.NewStore(idFn, ptrToFuncPtr)\n// assuming we transfer closure into another context\naccessCapture := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero)\naccessFunc := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one)\nresult := b.NewCall(b.NewLoad(idFn.Type(), accessFunc), b.NewLoad(captureTyp, accessCapture))\n\nprintIntegerFormat := m.NewGlobalDef(\"tmp\", irutil.NewCString(\"%d\\n\"))\npointerToString := b.NewGetElementPtr(types.NewArray(3, types.I8), printIntegerFormat, zero, zero)\n// ignore printf\nb.NewCall(printf, pointerToString, result)\n\nb.NewRet(constant.NewInt(types.I32, 0))","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"This is a huge example, I understand it's hard to read, but concept is clean. It would generate below LLVM IR:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"%id_capture = type { i32 }\n%id_closure = type { %id_capture*, i32 (%id_capture*)* }\n\n@tmp = global [3 x i8] c\"%d\\0A\"\n\ndeclare i32 @printf(i8* %format, ...)\n\ndefine i32 @id(%id_capture* %capture) {\n; <label>:0\n\t%1 = getelementptr %id_capture, %id_capture* %capture, i32 0, i32 0\n\t%2 = load i32, i32* %1\n\tret i32 %2\n}\n\ndefine i32 @main() {\n; <label>:0\n\t%1 = alloca i32\n\tstore i32 10, i32* %1\n\t%2 = alloca %id_capture\n\t%3 = getelementptr %id_capture, %id_capture* %2, i32 0, i32 0\n\t%4 = load i32, i32* %1\n\tstore i32 %4, i32* %3\n\t%5 = alloca %id_closure\n\t%6 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0\n\tstore %id_capture* %2, %id_capture** %6\n\t%7 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1\n\tstore i32 (%id_capture*)* @id, i32 (%id_capture*)** %7\n\t%8 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0\n\t%9 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1\n\t%10 = load i32 (%id_capture*)*, i32 (%id_capture*)** %9\n\t%11 = load %id_capture*, %id_capture** %8\n\t%12 = call i32 %10(%id_capture* %11)\n\t%13 = getelementptr [3 x i8], [3 x i8]* @tmp, i32 0, i32 0\n\t%14 = call i32 (i8*, ...) @printf(i8* %13, i32 %12)\n\tret i32 0\n}","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"Our id function captures an Integer and return it. To reach that id_capture was introduced for storing captured value. For passing whole closure in convenience, id_closure was introduced and stored capture structure and function pointer. When invoke a closure, get captured structure and function pointer from id_closure structure, then apply function with captured structure and additional arguments(if there's any). In this example omit the part about memory management, all structures allocated in the stack, this won't work in most real world case. Must notice this problem.","category":"page"},{"location":"user-guide/funcs/#Improvements","page":"More Function","title":"Improvements","text":"","category":"section"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"The naive implementation is not good enough, we have several ways can improve it, but instead of implementing them I'm going to list what can we do:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"Laziness function: Arity would be a thing in case\nAccess cross asynchronous model\nIf language has copy capture and reference capture, e.g. C++?\nWhat if working with a GC?","category":"page"},{"location":"user-guide/funcs/#Return-Structure","page":"More Function","title":"Return Structure","text":"","category":"section"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"When meet program that return structure by value, compiler has chance to remove such cloning. That's storing return structure into a reference passed by the caller. Which means, if we get:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"struct Foo {\n    // ...\n};\n\nFoo foo() {\n    Foo f;\n    // ...\n    return f;\n}","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"should compile to:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"define void @foo(%Foo* noalias sret f) {\n    // ...\n}","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"sret hints this is a return value.\nnoalias hints other arguments won't point to the same place, LLVM optimizer might rely on such fact, so don't add it everywhere.","category":"page"},{"location":"user-guide/funcs/#Add-parameter-attributes","page":"More Function","title":"Add parameter attributes","text":"","category":"section"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"Here is example shows how to add parameter attributes:","category":"page"},{"location":"user-guide/funcs/","page":"More Function","title":"More Function","text":"m := ir.NewModule()\n\nfooTyp := m.NewTypeDef(\"Foo\", types.NewStruct(\n\ttypes.I32,\n))\nretS := ir.NewParam(\"result\", fooTyp)\nretS.Attrs = append(retS.Attrs, enum.ParamAttrNoAlias)\nretS.Attrs = append(retS.Attrs, enum.ParamAttrSRet)\nm.NewFunc(\"foo\", types.Void, retS)","category":"page"},{"location":"#Welcome-to-llir/llvm","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"","category":"section"},{"location":"#Overview","page":"Welcome to llir/llvm","title":"Overview","text":"","category":"section"},{"location":"#Why-LLVM?","page":"Welcome to llir/llvm","title":"Why LLVM?","text":"","category":"section"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"When creating a compiler, a classical design may look like this:","category":"page"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"(Image: )","category":"page"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"This worked quite well in the old days. There was only one input language, and one target machine.","category":"page"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"Today there exist a lot of target machines to support! And a lot of input languages. Without a shared representation many parts of the compiler would have to be reimplemented for every input/output pair.","category":"page"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"LLVM offers a solution to this problem by defining such a shared representation, namely LLVM IR. Here is the new design:","category":"page"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"(Image: )","category":"page"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"To write a compiler for a new language, now we only have to focus on our frontend. Similarly, to add support for a new target machine, now we only have to add a new backend. And to improve the code generation of all input/output pairs, now we only have to focus on the middle end optimizer. Thank you, Chris Lattner and all those who have contributed to LLVM.","category":"page"},{"location":"#Why-llir/llvm?","page":"Welcome to llir/llvm","title":"Why llir/llvm?","text":"","category":"section"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"The aim of llir/llvm is to provide a library for interacting with LLVM IR in pure Go. Importantly, llir/llvm is not a binding for LLVM. Therefore, you don't have to compile LLVM (which could take a few hours), and no need to fight with Cgo. Work under a pure Go environment and start your journey.","category":"page"},{"location":"#Installation","page":"Welcome to llir/llvm","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"To install llir/llvm, all you need to do is: go get github.com/llir/llvm.","category":"page"},{"location":"#Usage","page":"Welcome to llir/llvm","title":"Usage","text":"","category":"section"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"According to packages, llir/llvm can be separated into two main parts:","category":"page"},{"location":"","page":"Welcome to llir/llvm","title":"Welcome to llir/llvm","text":"asm: This package implements a parser for LLVM IR assembly files. Users can use it for analyzing LLVM IR files.\nir: This package declares the types used to represent LLVM IR modules. Users can use it for build LLVM IR modules and operating on them.","category":"page"}]
}
